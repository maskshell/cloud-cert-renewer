---
description: Testing design principles and implementation guidelines
globs:
alwaysApply: true
---

# Testing Design Principles

## Overview

This document defines the testing design principles and implementation guidelines for the project. All tests must follow these principles to ensure consistency, maintainability, and alignment with the project's design patterns.

## Core Principles

### 1. Test Organization by Design Patterns

**Tests must be organized by design patterns, not by implementation details:**

- Each design pattern should have its own dedicated test file
- Test files should mirror the design pattern structure of the codebase
- Tests should focus on testing the design pattern layer, not the underlying implementation

**Test File Naming Convention:**
- Factory Pattern: `test_*_factory.py`
- Strategy Pattern: `test_*_strategy.py`
- Template Method Pattern: `test_*_base.py`
- Adapter Pattern: `test_*_adapter.py`
- Integration tests: `test_integration.py`
- Utility tests: `test_utils.py`
- Client implementation tests: `test_clients.py`
- Configuration tests: `test_config.py`

**Example Structure:**
```
tests/
├── test_clients.py              # Client implementation tests
├── test_config.py               # Configuration loading tests
├── test_utils.py                # Utility function tests
├── test_cert_renewer_factory.py # Factory Pattern tests
├── test_cert_renewer_strategy.py # Strategy Pattern tests
├── test_cert_renewer_base.py    # Template Method Pattern tests
├── test_auth_factory.py         # Auth Factory Pattern tests
├── test_auth_providers.py       # Auth Strategy Pattern tests
├── test_providers_adapter.py    # Adapter Pattern tests
├── test_container.py            # Dependency Injection tests
└── test_integration.py          # Integration tests
```

### 2. Test Design Pattern Alignment

**Tests must align with the design patterns used in the code:**

- **Factory Pattern Tests**: Test factory creation logic, verify correct instances are created
- **Strategy Pattern Tests**: Test strategy implementations, verify strategy switching and behavior
- **Template Method Pattern Tests**: Test template method flow, verify abstract method implementations
- **Adapter Pattern Tests**: Test adapter delegation, verify interface compliance
- **Dependency Injection Tests**: Test container registration, resolution, and singleton behavior

**Key Requirements:**
- Test the design pattern layer, not the underlying implementation
- Verify design pattern contracts and interfaces
- Test design pattern interactions and combinations
- Ensure design pattern extensibility

### 3. Test Hierarchy

**Tests must follow a clear hierarchy:**

1. **Unit Tests** (Priority: High)
   - Test individual components in isolation
   - Use mocks to isolate dependencies
   - Focus on single responsibility and behavior

2. **Integration Tests** (Priority: High)
   - Test complete workflows from configuration to execution
   - Test component interactions
   - Test dependency injection container usage

3. **Design Pattern Tests** (Priority: High)
   - Test design pattern implementations
   - Verify design pattern contracts
   - Test design pattern extensibility

### 4. Test Coverage Requirements

**Minimum coverage requirements:**

- All design pattern implementations must have dedicated tests
- All factory classes must be tested
- All strategy classes must be tested
- All template method classes must be tested
- All adapter classes must be tested
- All dependency injection components must be tested
- Integration tests must cover main workflows

**Coverage Goals:**
- Design pattern layer: 100% coverage
- Core business logic: 80%+ coverage
- Utility functions: 80%+ coverage
- Client implementations: 80%+ coverage

### 5. Mock Usage Principles

**When to use mocks:**

- Mock external dependencies (cloud APIs, file system, network)
- Mock design pattern dependencies to test in isolation
- Mock lower-level implementations when testing design pattern layer

**Mock Path Guidelines:**

- Mock at the design pattern boundary, not at implementation details
- Use correct import paths for mocking (e.g., `cloud_cert_renewer.clients.alibaba.CdnCertRenewer`)
- Mock the actual implementation being used, not intermediate layers

**Example:**
```python
# ✅ Correct: Mock at the client layer
@patch("cloud_cert_renewer.clients.alibaba.CdnCertRenewer.renew_cert")

# ❌ Incorrect: Mock at the strategy layer (tests implementation details)
@patch("cloud_cert_renewer.cert_renewer.cdn_renewer.CdnCertRenewer.renew_cert")
```

### 6. Test Naming Conventions

**Test class naming:**
- Use descriptive names: `TestCertRenewerFactory`, `TestCdnCertRenewerStrategy`
- Include the design pattern or component being tested
- Use `Test` prefix for test classes

**Test method naming:**
- Use descriptive names: `test_factory_create_cdn_renewer()`, `test_strategy_renew_success()`
- Follow pattern: `test_<component>_<behavior>_<expected_result>()`
- Use underscores, not camelCase

**Example:**
```python
class TestCertRenewerFactory(unittest.TestCase):
    def test_factory_create_cdn_renewer(self):
        """Test factory creates CDN renewer strategy"""
        pass
    
    def test_factory_invalid_service_type(self):
        """Test factory raises error for invalid service type"""
        pass
```

## Code Change Requirements

### Mandatory Test Updates

**When making code changes, tests MUST be updated accordingly:**

1. **Adding New Design Pattern Implementation:**
   - Create corresponding test file following naming convention
   - Test all design pattern contracts and behaviors
   - Add integration tests if applicable

2. **Modifying Existing Design Pattern:**
   - Update corresponding test file
   - Ensure all existing tests still pass
   - Add new tests for new behaviors

3. **Adding New Factory:**
   - Add tests to `test_*_factory.py`
   - Test factory creation logic
   - Test error handling

4. **Adding New Strategy:**
   - Add tests to `test_*_strategy.py`
   - Test strategy implementation
   - Test strategy switching

5. **Modifying Template Method:**
   - Update `test_*_base.py`
   - Test template method flow
   - Test abstract method implementations

6. **Adding New Adapter:**
   - Add tests to `test_*_adapter.py`
   - Test adapter delegation
   - Test interface compliance

7. **Modifying Dependency Injection:**
   - Update `test_container.py`
   - Test registration and resolution
   - Test singleton behavior

8. **Adding New Integration Flow:**
   - Add tests to `test_integration.py`
   - Test complete workflow
   - Test error handling

### Test Update Checklist

Before committing code changes:

- [ ] All existing tests pass
- [ ] New functionality has corresponding tests
- [ ] Tests follow design pattern organization
- [ ] Tests use appropriate mocks
- [ ] Test names are descriptive and follow conventions
- [ ] Integration tests cover new workflows
- [ ] Test coverage meets minimum requirements

## Best Practices

### 1. Test Independence

- Each test should be independent and runnable in isolation
- Use `setUp()` and `tearDown()` for test fixtures
- Avoid test dependencies and shared state

### 2. Test Clarity

- Tests should be self-documenting
- Use descriptive test names and docstrings
- Arrange-Act-Assert pattern for test structure

### 3. Test Maintainability

- Keep tests simple and focused
- Avoid complex test logic
- Use helper methods for common test setup

### 4. Test Performance

- Keep tests fast (unit tests should run in milliseconds)
- Use mocks to avoid slow external dependencies
- Group related tests in test classes

## Enforcement

### Pre-commit Checks

- All tests must pass before committing
- Test coverage should not decrease
- New code must have corresponding tests

### Code Review

- Reviewers should verify test coverage
- Reviewers should verify test organization follows design patterns
- Reviewers should verify tests align with code changes

### CI/CD Integration

- All tests must pass in CI/CD pipeline
- Test coverage reports should be generated
- Test failures should block deployment

## Examples

### Good Test Example

```python
class TestCertRenewerFactory(unittest.TestCase):
    """Certificate renewer factory tests (Factory Pattern)"""

    def test_factory_create_cdn_renewer(self):
        """Test factory creates CDN renewer strategy"""
        config = AppConfig(service_type="cdn", ...)
        renewer = CertRenewerFactory.create(config)
        
        self.assertIsInstance(renewer, BaseCertRenewer)
        self.assertIsInstance(renewer, CdnCertRenewerStrategy)
        self.assertEqual(renewer.config, config)
```

### Bad Test Example

```python
# ❌ Tests implementation details, not design pattern
class TestCdnRenewer(unittest.TestCase):
    def test_renew(self):
        # Directly tests client implementation
        result = CdnCertRenewer.renew_cert(...)
        # Should test through Strategy pattern instead
```

## Summary

- **Organize tests by design patterns**, not implementation details
- **Test the design pattern layer**, not underlying implementations
- **Update tests with every code change** following the same design patterns
- **Maintain test coverage** for all design pattern implementations
- **Use appropriate mocks** at design pattern boundaries
- **Follow naming conventions** for test files and methods
- **Ensure test independence** and maintainability
