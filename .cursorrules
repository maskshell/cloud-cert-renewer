# Iterative Development Rules

## Language Policy

**All project content must be in English:**

- All code comments and docstrings must be written in English
- All documentation files (README.md, CHANGELOG.md, etc.) must be in English
- All commit messages must be in English
- All configuration file comments must be in English
- All error messages and log messages should be in English
- All variable names, function names, and class names should use English words (following Python naming conventions)

**Exceptions:**

- Proper nouns (brand names, product names, company names) should use their official/standard names (e.g., "Alibaba Cloud" is the official English brand name, not "阿里云")
- Test data or example values that are intentionally in other languages for testing purposes
- Strings that are explicitly designated as non-English content (e.g., translation files, language-specific prompts, multilingual content) should be preserved as-is, even if they contain mixed languages

**Enforcement:**

- Code reviews should verify compliance with this policy
- Pre-commit hooks or CI/CD pipelines can be configured to check for non-English content in code and documentation
- When adding new files or modifying existing ones, ensure all text content follows this policy
- If you encounter non-English content that should be translated, create a separate issue or PR to address it

**Guidelines for Contributors:**

- If you're not a native English speaker, don't worry - clear and simple English is preferred over complex grammar
- Use tools like spell checkers and grammar checkers if needed
- When in doubt, ask for review or use translation tools, but always have a native speaker or experienced contributor review the final text
- Focus on clarity and correctness over perfect grammar - the goal is effective communication

## Core Principles

1. **Independent commits for each small iteration**
   - Each complete small iteration must be immediately committed with git
   - Commit messages should clearly describe the content and impact of this iteration
   - Each iteration should be atomic and independently revertible

2. **Iteration completeness requirements**
   - After each iteration, the code must be able to run completely
   - Iterations must not break the integrity of existing functionality
   - If an iteration involves configuration changes, backward-compatible default values or clear error messages must be provided

3. **Iteration pace control**
   - After each iteration is completed, pause and wait for user instructions
   - Do not perform multiple iterations consecutively unless explicitly requested by the user
   - Before proceeding to the next step, ensure the current iteration has been tested and verified

4. **Feature protection**
   - Maintain existing functionality unchanged during refactoring
   - If breaking changes are necessary, provide migration guides
   - When converting hardcoded values to environment variables, default values or clear error messages must be provided

5. **Commit conventions**
   - Commit message format: `type(scope): description`
   - Clearly describe the content of this change
   - List environment variables or configuration items that need to be set
   - Explain backward compatibility

6. **File Formatting**
   - When formatting files, first consider using the tools recommended in project rules for local formatting, rather than sending files to AI for formatting
   - Use project-standard formatting tools (e.g., `ruff format` for Python, `yamllint` for YAML)
   - Refer to [DEVELOPMENT.md](DEVELOPMENT.md) for specific formatting commands
   - Only use AI formatting when local tools are unavailable or insufficient

7. **Pre-Commit Code Quality Checks**
   - Before committing code changes, MUST run the following checks to ensure code quality (matching CI workflow in `.github/workflows/ci.yml`):
     - `uv run ruff format --check .` - Check code formatting (matches CI: line 35)
     - `uv run ruff check .` - Run linter (matches CI: line 38)
     - `uv run yamllint . --config-file .yamllint || true` - Check YAML files (matches CI: line 41, if YAML files were modified; `|| true` allows non-critical warnings)
   - If formatting check fails, run `uv run ruff format .` to auto-fix, then verify with `--check` again
   - If linting check fails, run `uv run ruff check . --fix` to auto-fix issues, then verify again
   - If any check fails after auto-fix attempts, manually fix the issues before committing
   - These checks MUST match the exact commands used in `.github/workflows/ci.yml` lint-and-format job
   - Exception: When user explicitly requests to skip checks (e.g., "commit without checks"), follow user's instruction

## Rule Management

1. **Rule Scale Management**
   - When recording rules, consider their scale and complexity
   - If a rule or set of rules becomes too large or complex, save it as a separate `.mdc` file
   - Keep `.cursorrules` focused on core principles and high-level guidelines
   - Use `.mdc` files for detailed, specialized rule sets (e.g., `testing-design-principles.mdc`)

2. **Rule Synchronization**
   - When adding or modifying rules, synchronize them to other similar rule files in the project
   - Key files that should be kept in sync:
     - `.cursorrules` - Main project rules file
     - `CLAUDE.md` - AI assistant guide with project rules
     - Other relevant `.mdc` files if applicable
   - Ensure consistency across all rule files to avoid conflicts or contradictions
   - When a rule is added to one file, check if it should also be added to related files

## Testing Design Principles

**All tests must follow the testing design principles defined in `testing-design-principles.mdc`:**

### Mandatory Test Updates

**When making code changes, tests MUST be updated accordingly using the same design patterns:**

1. **Adding New Design Pattern Implementation:**
   - Create corresponding test file following naming convention
   - Test all design pattern contracts and behaviors
   - Add integration tests if applicable

2. **Modifying Existing Design Pattern:**
   - Update corresponding test file
   - Ensure all existing tests still pass
   - Add new tests for new behaviors

3. **Test Organization:**
   - Tests must be organized by design patterns, not implementation details
   - Each design pattern should have its own dedicated test file
   - Test files should mirror the design pattern structure of the codebase

4. **Test Coverage:**
   - All design pattern implementations must have dedicated tests
   - Design pattern layer: 100% coverage
   - Core business logic: 80%+ coverage

5. **Test Update Checklist:**
   - [ ] All existing tests pass
   - [ ] New functionality has corresponding tests
   - [ ] Tests follow design pattern organization
   - [ ] Tests use appropriate mocks at design pattern boundaries
   - [ ] Test names are descriptive and follow conventions
   - [ ] Integration tests cover new workflows

**See `testing-design-principles.mdc` for complete testing guidelines.**
